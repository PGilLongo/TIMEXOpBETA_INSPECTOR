<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Base de datos</title>
<style>
  :root{
    --w95-bg:#c0c0c0;
    --w95-light:#ffffff;
    --w95-shadow:#404040;
    --w95-blue:#000080;
    --w95-hilite:#dfdfdf;
  }

  *{ box-sizing:border-box; }

  html,body{ height:100%; }
  body{
    margin:0;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    background: var(--w95-bg);
    color:#000;
  }

  .window{
    border-top:2px solid var(--w95-light);
    border-left:2px solid var(--w95-light);
    border-right:2px solid var(--w95-shadow);
    border-bottom:2px solid var(--w95-shadow);
    background: var(--w95-bg);
    box-shadow: 2px 2px 0 rgba(0,0,0,.2);
  }

  .titlebar{
    background: var(--w95-blue);
    color:#fff;
    padding:4px 8px;
    font-weight:800;
    font-size:13px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    position:sticky;
    top:0;
    z-index:50;
    border-bottom:2px solid var(--w95-shadow);
    user-select:none;
  }

  .content{ padding:12px; }

  .toolbar{
    display:flex;
    flex-wrap:wrap;
    gap:8px;
    align-items:center;
    justify-content:space-between;
    margin-top:10px;
  }

  .group{
    display:flex;
    gap:8px;
    align-items:center;
    flex-wrap:wrap;
    min-width:0;
  }

  label{
    display:block;
    font-size:12px;
    margin-bottom:4px;
    font-weight:700;
  }

  input[type="text"],
  input[type="datetime-local"],
  select{
    width:100%;
    max-width: 100%;
    min-width: 0;
    padding:6px 8px;
    border-top:2px solid var(--w95-shadow);
    border-left:2px solid var(--w95-shadow);
    border-right:2px solid var(--w95-light);
    border-bottom:2px solid var(--w95-light);
    background:#fff;
    font-size:13px;
    font-family: inherit;
  }

  select{ width: 100%; }

  button{
    border-top:2px solid var(--w95-light);
    border-left:2px solid var(--w95-light);
    border-right:2px solid var(--w95-shadow);
    border-bottom:2px solid var(--w95-shadow);
    background: var(--w95-bg);
    padding:6px 10px;
    font-weight:800;
    font-size:12px;
    font-family: inherit;
    cursor:pointer;
  }
  button:active{
    border-top:2px solid var(--w95-shadow);
    border-left:2px solid var(--w95-shadow);
    border-right:2px solid var(--w95-light);
    border-bottom:2px solid var(--w95-light);
  }
  button.primary{ background: var(--w95-hilite); }
  button.danger{ background:#ffd6d6; }

  .workspace{
    width:100%;
    margin:0;
    padding:0;
  }

  .panel{ padding:0; }

  .panel.window{
    width:100%;
    min-height:100vh;
    box-shadow:none;
  }

  h3{
    margin:0 0 10px;
    font-size:14px;
  }

  .box{
    padding:10px;
    background: var(--w95-hilite);
    border-top:2px solid var(--w95-shadow);
    border-left:2px solid var(--w95-shadow);
    border-right:2px solid var(--w95-light);
    border-bottom:2px solid var(--w95-light);
    margin-bottom:10px;
  }

  .gridFilters{
    display:grid;
    grid-template-columns: repeat(12, minmax(0, 1fr));
    gap:10px;
    align-items:end;
  }
  .gridFilters > div{ min-width:0; }

  .col-12{ grid-column: span 12; }
  .col-6{ grid-column: span 6; }
  .col-4{ grid-column: span 4; }
  .col-3{ grid-column: span 3; }

  @media (max-width: 900px){
    .col-6, .col-4, .col-3{ grid-column: span 12; }
    input[type="text"], input[type="datetime-local"], select{ width: 100%; max-width: 100%; }
  }

  .histEmpty{
    padding:14px;
    background: #fff;
    border-top:2px solid var(--w95-shadow);
    border-left:2px solid var(--w95-shadow);
    border-right:2px solid var(--w95-light);
    border-bottom:2px solid var(--w95-light);
    font-size:13px;
  }

  table.histTable{
    width:100%;
    border-collapse:collapse;
    background:#fff;
    border-top:2px solid var(--w95-shadow);
    border-left:2px solid var(--w95-shadow);
    border-right:2px solid var(--w95-light);
    border-bottom:2px solid var(--w95-light);
    font-size:13px;
  }
  table.histTable th, table.histTable td{
    padding:8px 10px;
    border-bottom:1px solid #d0d0d0;
    text-align:left;
    vertical-align:middle;
  }
  table.histTable th{
    background: var(--w95-hilite);
    font-size:12px;
    user-select:none;
  }
  table.histTable tr:hover td{ background:#f6f6ff; }

  .muted{ opacity:.75; font-size:12px; }

  .pager{
    margin-top:10px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    flex-wrap:wrap;
  }
  .pager .meta{
    font-size:12px;
    opacity:.85;
  }
  .pager .controls{
    display:flex;
    gap:8px;
    align-items:center;
    flex-wrap:wrap;
  }
  .pill{
    display:inline-block;
    padding:4px 8px;
    background:#fff;
    border-top:2px solid var(--w95-shadow);
    border-left:2px solid var(--w95-shadow);
    border-right:2px solid var(--w95-light);
    border-bottom:2px solid var(--w95-light);
    font-size:12px;
    font-weight:800;
  }
</style>

<!-- 1) Firebase (compat, sin bundler) -->
<script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore-compat.js"></script>
</head>

<body>
<div class="workspace">
  <div class="panel window">
    <div class="titlebar">
      <div>Base de datos</div>
      </div>
    <div class="content">

      <div class="box" style="margin-top:10px;">
        <div class="gridFilters">
          <div class="col-12">
            <label>Búsqueda rápida</label>
            <input id="histSearch" type="text" placeholder="Filtra por texto…" oninput="resetToFirstPageAndRender()" />
            <div style="display:flex; gap:10px; margin-top:10px; align-items:center;">
              <button type="button" onclick="runSearch()">Buscar</button>
              <button type="button" onclick="loadAllFromCloud()">Cargar todas</button>
              <div class="muted">Consejo: TAG/código exacto usa "Buscar". "Cargar todas" trae todo y filtra local.</div>
            </div>
            <div class="muted" style="margin-top:6px">
              Consejo: busca por categoría, formulario o cualquier texto que exista dentro del JSON (incluye TAG/código).
            </div>
          </div>

          <div class="col-3">
            <label>Filtro: categoría</label>
            <select id="advCategory" onchange="resetToFirstPageAndRender()">
              <option value="">(Todas)</option>
            </select>
          </div>

          <div class="col-3">
            <label>Filtro: formulario contiene</label>
            <input id="advForm" type="text" placeholder="Ej: Checklist…" oninput="resetToFirstPageAndRender()" />
          </div>

          <div class="col-3">
            <label>Fecha desde</label>
            <input id="advFrom" type="datetime-local" onchange="resetToFirstPageAndRender()" />
          </div>

          <div class="col-3">
            <label>Fecha hasta</label>
            <input id="advTo" type="datetime-local" onchange="resetToFirstPageAndRender()" />
          </div>

          <div class="col-12" style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
            <button type="button" onclick="clearAdvancedFilters()">Limpiar filtros</button>
            <span class="muted">Mostrando <b>50</b> registros por página.</span>
          </div>
        </div>
      </div>

      <div id="histList"></div>
    </div>
  </div>
</div>

<script>
/* __GLOBAL_ERROR_WIRED__ */
window.addEventListener('error', (e)=>{
  console.error('JS error:', e.error || e.message, e);
});
window.addEventListener('unhandledrejection', (e)=>{
  console.error('Unhandled promise rejection:', e.reason);
});

/**
 * 2) Firebase config (literal)
 */
const firebaseConfig = {
  apiKey: "AIzaSyBLP0yGc_Yh0nKGNYbPcYabTg25LDw2wco",
  authDomain: "inspector-b4f41.firebaseapp.com",
  projectId: "inspector-b4f41",
  storageBucket: "inspector-b4f41.firebasestorage.app",
  messagingSenderId: "333394046622",
  appId: "1:333394046622:web:caa18c6f1d341b0a97158f"
};



  function fsErrShort(e){
    try{
      const code = e && (e.code || e.name) ? String(e.code || e.name) : '';
      const msg = e && e.message ? String(e.message) : String(e||'');
      const out = (code && msg) ? (code + ' — ' + msg) : (code || msg);
      return out.trim() || 'error';
    }catch(_){ return 'error'; }
  }
  function fsRulesHint(e){
    const s = (e && (e.code || '') ? String(e.code) : '') + ' ' + (e && e.message ? String(e.message) : '');
    if(/permission-denied/i.test(s)){
      return "\n\nParece un problema de REGLAS: si no usas login, Firestore debe permitir lecturas/escrituras públicas (o habilitar Auth).";
    }
    if(/failed-precondition/i.test(s) && /index/i.test(s)){
      return "\n\nParece faltar un índice compuesto en Firestore (consola -> Firestore -> Indexes).";
    }
    if(/unavailable|network|offline|fetch/i.test(s)){
      return "\n\nParece un problema de conexión/red o bloqueo del navegador.";
    }
    return "";
  }

/**
 * Firestore: colección persistente
 * 3) Estructura en templates_v1:
 * DocID: <id>
 * {
 *   name: string,
 *   category: string,
 *   code: string,
 *   createdAt: ISOstring,
 *   updatedAt: ISOstring,
 *   data: object
 * }
 */
const COLLECTION_NAME = 'inspections_v1';
const INS_COLLECTION = COLLECTION_NAME;
const PAGE_SIZE = 50;

let __page = 1;

// Cache en memoria (la fuente de verdad SIEMPRE es Firestore)
let __dbCache = [];
let __cacheLoaded = false;
let __loadedAll = false; // si se ha hecho "Cargar todas"

let __fire = {
  app: null,
  db: null,
  col: null
};

function nowISO(){
  try{ return new Date().toISOString(); }catch(e){ return ''+Date.now(); }
}
function makeId(){
  return 'id_' + Date.now().toString(36) + '_' + Math.random().toString(36).slice(2, 10);
}
function normalizeStr(s){ return String(s ?? '').trim(); }
function normalizeLower(s){ return normalizeStr(s).toLowerCase(); }

function stableSerialize(val){
  const t = typeof val;
  if(val === null) return 'null';
  if(t === 'string') return JSON.stringify(val);
  if(t === 'number' || t === 'boolean') return String(val);
  if(t !== 'object') return JSON.stringify(String(val));
  if(Array.isArray(val)){
    return '[' + val.map(stableSerialize).join(',') + ']';
  }
  const keys = Object.keys(val).sort((a,b)=> a.localeCompare(b, 'en', { sensitivity:'base' }));
  return '{' + keys.map(k => JSON.stringify(k)+':'+stableSerialize(val[k])).join(',') + '}';
}

function hashString(str){
  // DJB2 (32-bit) for speed + determinism
  let h = 5381;
  for(let i=0;i<str.length;i++){
    h = ((h << 5) + h) ^ str.charCodeAt(i);
  }
  return (h >>> 0).toString(16).padStart(8,'0');
}

function computeFingerprint(category, form, lastEditedISO, raw){
  try{
    const layout = extractLayout(raw) || raw || {};
    // Evita que pequeñas diferencias irrelevantes rompan el hash
    const payload = {
      category: normalizeStr(category),
      form: normalizeStr(form),
      lastEditedISO: normalizeStr(lastEditedISO),
      layout: layout
    };
    return hashString(stableSerialize(payload));
  }catch(e){
    return hashString(String(Date.now()) + Math.random());
  }
}

function hasLayoutShape(obj){
  return !!(obj && typeof obj === 'object' && obj.header && typeof obj.header === 'object' && Array.isArray(obj.fields));
}

function extractLayout(raw){
  if(!raw || typeof raw !== 'object') return null;
  if(hasLayoutShape(raw)) return raw;
  if(raw.data && typeof raw.data === 'object' && hasLayoutShape(raw.data)) return raw.data;
  if(raw.layout && typeof raw.layout === 'object' && hasLayoutShape(raw.layout)) return raw.layout;
  return null;
}

function normalizeImportedRecord(raw){
  if(!raw || typeof raw !== 'object') return null;

  const layout = extractLayout(raw);
  if(!layout) return null;

  const header = (layout.header && typeof layout.header === 'object') ? layout.header : {};
  const metaRaw = (raw.meta && typeof raw.meta === 'object') ? raw.meta : {};
  const metaLayout = (layout.meta && typeof layout.meta === 'object') ? layout.meta : {};

  const category = normalizeStr(raw.category || metaRaw.category || metaLayout.category || '');
  const form = normalizeStr(raw.form || raw.name || metaRaw.name || metaRaw.form || metaLayout.name || metaLayout.form || '');

  if(!category || !form) return null;

  const tagCode = normalizeStr(raw.tag || raw.code || metaRaw.tag || metaRaw.code || metaLayout.tag || metaLayout.code || '');

  const lastEditedISO = normalizeStr(
    raw.lastEditedISO ||
    raw.lastEdited ||
    metaRaw.inspectionLastEditedAtISO ||
    metaLayout.inspectionLastEditedAtISO ||
    header.lastEdited ||
    nowISO()
  );

  return {
    id: makeId(),
    category,
    form,
    lastEditedISO,
    fingerprint: (tagCode ? tagCode : computeFingerprint(category, form, lastEditedISO, raw)),
    raw
  };
}

/**
 * Adaptación:
 * - UI trabaja con registros "inspecciones" {id, category, form, lastEditedISO, fingerprint, raw}
 * - Firestore guarda "templates" {id, name, category, code, createdAt, updatedAt, data}
 * Mapeamos:
 *   name = form
 *   code = fingerprint (TAG/código)
 *   data = raw (objeto serializado que ya existía)
 */
function recordToTemplate(rec, existingTpl){
  const id = normalizeStr(rec?.id) || normalizeStr(existingTpl?.id) || makeId();
  const createdAt = normalizeStr(existingTpl?.createdAt) || nowISO();
  const updatedAt = nowISO();
  const category = normalizeStr(rec?.category || existingTpl?.category || '');
  const name = normalizeStr(rec?.form || existingTpl?.name || '');
  const code = normalizeStr(rec?.fingerprint || existingTpl?.code || '');
  const data = (rec && rec.raw && typeof rec.raw === 'object') ? rec.raw : ((existingTpl && existingTpl.data && typeof existingTpl.data === 'object') ? existingTpl.data : (rec?.raw || rec || {}));

  return { id, name, category, code, createdAt, updatedAt, data };
}

function templateToRecord(tpl){
  const id = normalizeStr(tpl?.id) || makeId();
  const category = normalizeStr(tpl?.category || '');
  const form = normalizeStr(tpl?.name || '');
  const fingerprint = normalizeStr(tpl?.code || '');
  const raw = (tpl && tpl.data && typeof tpl.data === 'object') ? tpl.data : {};

  // lastEditedISO: si viene en data, úsalo; si no, usa updatedAt (o createdAt)
  const lastEditedISO =
    normalizeStr(raw?.lastEditedISO || raw?.lastEdited) ||
    normalizeStr(tpl?.updatedAt || tpl?.createdAt) ||
    nowISO();

  return { id, category, form, lastEditedISO, fingerprint, raw };
}

function ensureDbShape(items){
  let changed = false;
  const out = [];

  for(const it of (Array.isArray(items) ? items : [])){
    if(!it || typeof it !== 'object') continue;

    // Si ya viene con forma de record (tiene category/form/raw), pásalo
    if(('category' in it) || ('form' in it) || ('raw' in it)){
      const obj = { ...it };

      if(!obj.id){ obj.id = makeId(); changed = true; }

      if(!obj.raw){
        const snap = { ...obj };
        delete snap.raw;
        obj.raw = snap;
        changed = true;
      }

      if(!obj.lastEditedISO){
        obj.lastEditedISO = nowISO();
        changed = true;
      }

      if(!obj.fingerprint){
        obj.fingerprint = computeFingerprint(obj.category || '', obj.form || '', obj.lastEditedISO || '', obj.raw || obj);
        changed = true;
      }

      out.push(obj);
      continue;
    }

    // Si es un objeto "layout" o export, intenta normalizar
    const wrapped = normalizeImportedRecord(it);
    if(wrapped){ out.push(wrapped); changed = true; }
  }

  // Deduplicación defensiva por fingerprint (code)
  const seen = new Set();
  const unique = [];
  for(const it of out){
    const fp = it && it.fingerprint ? String(it.fingerprint) : '';
    if(fp && seen.has(fp)){ changed = true; continue; }
    if(fp) seen.add(fp);
    unique.push(it);
  }

  return { items: unique, changed };
}

/* =========================
   4) Operaciones Firestore
   ========================= */

function assertFirestoreReady(){
  if(!__fire.db || !__fire.col) throw new Error('Firestore no inicializado.');
}

/**
 * fetchAllTemplates(): leer todos los docs de "templates_v1"
 */
async function fetchAllInspections(){
  if(!__fire.db) throw new Error('Firestore no inicializado.');
  const snap = await __fire.db.collection(INS_COLLECTION).get();
  const out = [];
  snap.forEach(doc=>{
    const d = doc.data() || {};
    if(!d.id) d.id = doc.id;
    out.push(d);
  });
  return out;
}
/**
 * fetchLatestInspections(limit): carga últimas N inspecciones (orden por updatedAt/createdAt si existe)
 */
async function fetchLatestInspections(limit){
  if(!__fire.db) throw new Error('Firestore no inicializado.');
  const lim = Math.max(1, Number(limit||200));
  // Preferimos updatedAt/createdAt si existen (strings ISO). Si no, caemos a get() simple.
  try{
    return await __fire.db.collection(INS_COLLECTION).orderBy('updatedAt', 'desc').limit(lim).get()
      .then(snap=>{
        const out=[]; snap.forEach(doc=>{ const d=doc.data()||{}; if(!d.id) d.id=doc.id; out.push(d);}); return out;
      });
  }catch(e1){
    try{
      return await __fire.db.collection(INS_COLLECTION).orderBy('createdAt', 'desc').limit(lim).get()
        .then(snap=>{
          const out=[]; snap.forEach(doc=>{ const d=doc.data()||{}; if(!d.id) d.id=doc.id; out.push(d);}); return out;
        });
    }catch(e2){
      // fallback
      return await fetchAllInspections();
    }
  }
}

/**
 * fetchInspectionsByCode(code): búsqueda exacta por TAG/código
 */
async function fetchInspectionsByCode(code){
  if(!__fire.db) throw new Error('Firestore no inicializado.');
  const c = String(code||'').trim();
  if(!c) return [];
  const snap = await __fire.db.collection(INS_COLLECTION).where('code', '==', c).get();
  const out = [];
  snap.forEach(doc=>{
    const d = doc.data() || {};
    if(!d.id) d.id = doc.id;
    out.push(d);
  });
  return out;
}


/**
 * upsertTemplate(tpl): set(doc).merge(true) con payload anterior
 */
async function upsertInspectionRaw(raw){
  if(!__fire.db) throw new Error('Firestore no inicializado.');
  if(!raw || typeof raw !== 'object') throw new Error('invalid_payload');
  const id = String(raw.id || makeId());
  const payload = { ...raw, id, updatedAt: firebase.firestore.FieldValue.serverTimestamp() };
  await __fire.db.collection(INS_COLLECTION).doc(id).set(payload, { merge:true });
  return id;
}

/**
 * deleteTemplate(id): borrar doc
 */
async function deleteInspection(id){
  if(!__fire.db) throw new Error('Firestore no inicializado.');
  await __fire.db.collection(INS_COLLECTION).doc(String(id)).delete();
  return true;
}

/**
 * deleteAllTemplates(): borrar todos los docs (batch)
 * (en chunks de 450 para ir holgados bajo el límite de 500)
 */
async function deleteAllInspections(){
  if(!__fire.db) throw new Error('Firestore no inicializado.');
  const snap = await __fire.db.collection(INS_COLLECTION).get();
  const docs = [];
  snap.forEach(d=>docs.push(d));
  let i = 0;
  while(i < docs.length){
    const chunk = docs.slice(i, i+400);
    const batch = __fire.db.batch();
    for(const d of chunk) batch.delete(d.ref);
    await batch.commit();
    i += chunk.length;
  }
  return true;
}

/**
 * findByCode(code): query where('code','==',code).limit(1)
 */
async function findByCode(code){
  assertFirestoreReady();
  const c = normalizeStr(code);
  if(!c) return null;
  const q = await __fire.col.where('code', '==', c).limit(1).get();
  if(q.empty) return null;
  const doc = q.docs[0];
  return { id: doc.id, ...(doc.data() || {}) };
}

/* =========================
   UI + Lógica (sin localStorage)
   ========================= */

async function loadDB(){
  // la fuente de verdad es Firestore (inspecciones)
  const rows = await fetchLatestInspections(200);
  const records = [];
  for(const raw of rows){
    const rec = normalizeImportedRecord((raw && raw.data && typeof raw.data==='object') ? raw.data : raw);
    if(rec){
      rec.id = String(raw.id || rec.id);
      if(raw.fingerprint) rec.fingerprint = String(raw.fingerprint);
      records.push(rec);
    }
  }
  const shaped = ensureDbShape(records);
  __dbCache = shaped.items;
  __cacheLoaded = true;
  return __dbCache;
}

function getCache(){
  return Array.isArray(__dbCache) ? __dbCache : [];
}

async function refreshCache(){
  await loadDB();
}

/**
 * Cargar todas las inspecciones (Firestore) y permitir filtrado local completo.
 * Ojo: si hay MUCHAS, puede tardar.
 */
async function loadAllFromCloud(){
  if(!confirm('Esto cargará TODAS las inspecciones desde Firestore (puede tardar). ¿Continuar?')) return;
  const wrap = document.getElementById('histList');
  try{
    if(wrap){
      wrap.innerHTML = '<div class="histEmpty">Cargando todas desde Firestore…</div>';
    }
    const rows = await fetchAllInspections();
    const records = [];
    for(const raw of rows){
      const rec = normalizeImportedRecord((raw && raw.data && typeof raw.data==='object') ? raw.data : raw);
      if(rec){
        rec.id = String(raw.id || rec.id);
        records.push(rec);
      }
    }
    __dbCache = ensureDbShape(records).items;
    __cacheLoaded = true;
    __loadedAll = true;
    __page = 1;
    refreshCategoryOptions();
    await renderList();
  }catch(e){
    console.error(e);
    alert('No se pudo cargar todo.\n' + (e && (e.message||e.toString()) ? (e.message||e.toString()) : ''));
  }
}

/**
 * Buscar por TAG/código (exacto) en Firestore.
 * Si no encuentra y no se ha cargado todo, ofrece cargar todo y filtrar por texto.
 */
async function runSearch(){
  const q = String((document.getElementById('histSearch')||{}).value || '').trim();
  if(!q){
    // si no hay query, vuelve a "últimas"
    __cacheLoaded = false;
    __loadedAll = false;
    __page = 1;
    await renderList();
    return;
  }

  const wrap = document.getElementById('histList');
  try{
    if(wrap){
      wrap.innerHTML = '<div class="histEmpty">Buscando en Firestore…</div>';
    }

    // 1) Búsqueda exacta (rápida)
    const rows = await fetchInspectionsByCode(q);

    if(rows && rows.length){
      const records = [];
      for(const raw of rows){
        const rec = normalizeImportedRecord((raw && raw.data && typeof raw.data==='object') ? raw.data : raw);
        if(rec){
          rec.id = String(raw.id || rec.id);
          records.push(rec);
        }
      }
      __dbCache = ensureDbShape(records).items;
      __cacheLoaded = true;
      __page = 1;
      refreshCategoryOptions();
      await renderList();
      return;
    }

    // 2) Si no hay resultados, y no hemos cargado todo, hacemos fallback a "últimas 200" y filtrado local por texto
    if(!__loadedAll){
      const latest = await fetchLatestInspections(200);
      const records = [];
      for(const raw of latest){
        const rec = normalizeImportedRecord((raw && raw.data && typeof raw.data==='object') ? raw.data : raw);
        if(rec){
          rec.id = String(raw.id || rec.id);
          records.push(rec);
        }
      }
      __dbCache = ensureDbShape(records).items;
      __cacheLoaded = true;
      __page = 1;
      refreshCategoryOptions();
      await renderList(); // applyFilters ya usa histSearch
      // si aún así no aparece, sugerimos cargar todo
      const filtered = applyFilters(getCache());
      if(!filtered.length){
        if(confirm('No se encontró nada por código exacto ni en las últimas 200. ¿Quieres CARGAR TODAS para buscar por texto en todo el histórico?')){
          await loadAllFromCloud();
        }
      }
      return;
    }

    // 3) Ya estaba cargado todo y no apareció: render normal (applyFilters mostrará vacío)
    await renderList();
  }catch(e){
    console.error(e);
    alert('No se pudo buscar.\n' + (e && (e.message||e.toString()) ? (e.message||e.toString()) : ''));
  }
}


async function clearDB(){
  if(!confirm('¿Vaciar por completo la base de datos en la nube (Firestore)?')) return;
  try{
    await deleteAllInspections();
    __page = 1;
    await refreshCache();
    refreshCategoryOptions();
    await renderList();
  }catch(e){
    console.error(e);
    alert('No se pudo vaciar la base de datos.');
  }
}

function parseDateSafe(v){
  if(!v) return null;
  const d = new Date(v);
  if(isNaN(d.getTime())) return null;
  return d;
}

function formatDateDDMMYYYY_HHMM(input){
  const d = (input instanceof Date) ? input : parseDateSafe(input);
  if(!d) return '—';
  const pad = (n)=> String(n).padStart(2,'0');
  const dd = pad(d.getDate());
  const mm = pad(d.getMonth()+1);
  const yyyy = d.getFullYear();
  const hh = pad(d.getHours());
  const mi = pad(d.getMinutes());
  return `${dd}/${mm}/${yyyy} ${hh}:${mi}`;
}

function resetToFirstPageAndRender(){
  __page = 1;
  // renderList ya usa cache; si quieres reflejar cambios remotos, recarga:
  renderList();
}

function clearAdvancedFilters(){
  document.getElementById('advCategory').value = '';
  document.getElementById('advForm').value = '';
  document.getElementById('advFrom').value = '';
  document.getElementById('advTo').value = '';
  document.getElementById('histSearch').value = '';
  __page = 1;
  renderList();
}

function refreshCategoryOptions(){
  const sel = document.getElementById('advCategory');
  if(!sel) return;

  const current = sel.value || '';
  const db = getCache();
  const cats = [...new Set(db.map(x => normalizeStr(x?.category)).filter(Boolean))]
    .sort((a,b)=> a.localeCompare(b, 'es', { sensitivity: 'base' }));

  sel.innerHTML = `<option value="">(Todas)</option>` + cats.map(c=>{
    const safe = c.replaceAll('"','&quot;');
    return `<option value="${safe}">${safe}</option>`;
  }).join('');

  if(current && cats.includes(current)) sel.value = current;
}

function applyFilters(db){
  const q = normalizeLower(document.getElementById('histSearch').value);
  const cat = normalizeStr(document.getElementById('advCategory').value);
  const formLike = normalizeLower(document.getElementById('advForm').value);

  const fromVal = document.getElementById('advFrom').value;
  const toVal = document.getElementById('advTo').value;

  const from = parseDateSafe(fromVal ? fromVal : null);
  const to = parseDateSafe(toVal ? toVal : null);

  const toMs = to ? to.getTime() : null;
  const fromMs = from ? from.getTime() : null;

  return db.filter(e=>{
    if(!e) return false;

    if(q){
      try{
        // Incluye fingerprint (TAG/código) y raw
        if(!JSON.stringify(e).toLowerCase().includes(q)) return false;
      }catch(err){}
    }

    if(cat && normalizeStr(e.category) !== cat) return false;

    if(formLike){
      const f = normalizeLower(e.form);
      if(!f.includes(formLike)) return false;
    }

    if(fromMs !== null || toMs !== null){
      const d = parseDateSafe(e.lastEditedISO);
      if(!d) return false;
      const t = d.getTime();
      if(fromMs !== null && t < fromMs) return false;
      if(toMs !== null && t > toMs) return false;
    }

    return true;
  });
}

async function renderList(){
  const wrap = document.getElementById('histList');
  if(!wrap) return;

  // Si aún no cargó cache, cárgala (Firestore)
  if(!__cacheLoaded){
    wrap.innerHTML = '';
    const div = document.createElement('div');
    div.className = 'histEmpty';
    div.textContent = 'Conectando a Firestore…';
    wrap.appendChild(div);

    try{
      await refreshCache();
    }catch(e){
      console.error(e);
      wrap.innerHTML = '';
      const err = document.createElement('div');
      err.className = 'histEmpty';
      err.textContent = 'No se pudo conectar a Firestore. Revisa la conexión y la configuración.';
      wrap.appendChild(err);
      return;
    }
  }

  const db = getCache();
  refreshCategoryOptions();

  const filtered = applyFilters(db);

  wrap.innerHTML = '';
  if(filtered.length === 0){
    const div = document.createElement('div');
    div.className = 'histEmpty';
    div.textContent = db.length === 0
      ? 'No hay inspecciones guardadas todavía.'
      : 'No hay inspecciones que coincidan con los filtros.';
    wrap.appendChild(div);
    return;
  }

  const itemsSorted = filtered
    .slice()
    .sort((a,b)=> String(b.lastEditedISO||'').localeCompare(String(a.lastEditedISO||'')));

  const total = itemsSorted.length;
  const totalPages = Math.max(1, Math.ceil(total / PAGE_SIZE));
  if(__page > totalPages) __page = totalPages;
  if(__page < 1) __page = 1;

  const start = (__page - 1) * PAGE_SIZE;
  const end = Math.min(start + PAGE_SIZE, total);
  const pageItems = itemsSorted.slice(start, end);

  const table = document.createElement('table');
  table.className = 'histTable';
  table.innerHTML = `
    <thead>
      <tr>
        <th>Fecha</th>
        <th>Categoría</th>
        <th>Formulario</th>
        <th>PDF</th>
      </tr>
    </thead>
    <tbody></tbody>
  `;

  const tbody = table.querySelector('tbody');

  pageItems.forEach(e=>{
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${formatDateDDMMYYYY_HHMM(e.lastEditedISO)}</td>
      <td>${e.category || '—'}</td>
      <td>${e.form || '—'}</td>
      <td><button type="button" class="primary" onclick="exportRecordPDF('${e.id}')">Exportar</button></td>
    `;
    tbody.appendChild(tr);
  });

  wrap.appendChild(table);

  const pager = document.createElement('div');
  pager.className = 'pager';
  pager.innerHTML = `
    <div class="meta">
      Mostrando <span class="pill">${start + 1}–${end}</span> de <span class="pill">${total}</span> resultados
      · Página <span class="pill">${__page}</span> / <span class="pill">${totalPages}</span>
    </div>
    <div class="controls">
      <button type="button" onclick="setPage(1)" ${__page===1?'disabled':''}>⏮ Primera</button>
      <button type="button" onclick="setPage(${__page-1})" ${__page===1?'disabled':''}>◀ Anterior</button>
      <button type="button" onclick="setPage(${__page+1})" ${__page===totalPages?'disabled':''}>Siguiente ▶</button>
      <button type="button" onclick="setPage(${totalPages})" ${__page===totalPages?'disabled':''}>Última ⏭</button>
    </div>
  `;
  wrap.appendChild(pager);
}

function setPage(p){
  __page = Number(p) || 1;
  renderList();
}

/**
 * Importar JSON:
 * - Normaliza registros como antes
 * - Guarda cada registro como template en Firestore (upsert)
 * - (Opcional) evita duplicados por TAG/código (code = fingerprint) consultando cache
 */
function importJsonFiles(){
  const inp = document.createElement('input');
  inp.type = 'file';
  inp.accept = 'application/json,.json';
  inp.multiple = true;

  inp.onchange = async ()=>{
    const files = [...(inp.files || [])];

    // Asegura cache para dedupe por fingerprint (code)
    try{
      if(!__cacheLoaded) await refreshCache();
    }catch(e){}

    const db = getCache();
    const seen = new Set(db.map(x=>String(x?.fingerprint||'')).filter(Boolean));

    let importedCount = 0;

    for(const f of files){
      try{
        const txt = await f.text();
        const obj = JSON.parse(txt);

        // Soporta export del Inspector con múltiples inspecciones en un solo archivo
        if(obj && typeof obj === 'object' && obj.format === 'inspector_inspections_v1' && Array.isArray(obj.inspections)){
          for(const one of obj.inspections){
            const rec = normalizeImportedRecord(one);
            if(rec && rec.fingerprint && !seen.has(String(rec.fingerprint))){
              // upsert a Firestore
              rec.id = rec.id || makeId();
              const tpl = recordToTemplate(rec, null);

              // Si ya existe por code, reutiliza su docId para merge
              const existing = await findByCode(tpl.code);
              if(existing && existing.id){
                tpl.id = existing.id;
                tpl.createdAt = existing.createdAt || tpl.createdAt;
              }

              await upsertInspectionRaw(tpl);
              seen.add(String(rec.fingerprint));
              importedCount++;
            }
          }
          continue;
        }

        // Caso normal: un JSON = un registro
        const rec = normalizeImportedRecord(obj);
        if(rec && rec.fingerprint && !seen.has(String(rec.fingerprint))){
          rec.id = rec.id || makeId();
          const tpl = recordToTemplate(rec, null);

          const existing = await findByCode(tpl.code);
          if(existing && existing.id){
            tpl.id = existing.id;
            tpl.createdAt = existing.createdAt || tpl.createdAt;
          }

          await upsertInspectionRaw(tpl);
          seen.add(String(rec.fingerprint));
          importedCount++;
        }
      }catch(e){}
    }

    await refreshCache();
    __page = 1;
    refreshCategoryOptions();
    await renderList();

    if(importedCount === 0){
      alert('No se importaron nuevos registros (puede que ya existan por TAG/código).');
    }
  };

  inp.click();
}

let __exportFrame = null;

function exportStamp(date){
  const d = date instanceof Date ? date : new Date();
  const pad = (n)=> String(n).padStart(2,'0');
  const y = d.getFullYear();
  const m = pad(d.getMonth()+1);
  const da = pad(d.getDate());
  const h = pad(d.getHours());
  const mi = pad(d.getMinutes());
  const s = pad(d.getSeconds());
  return `${y}-${m}-${da}_${h}-${mi}-${s}`;
}

function makeSafeName(name, fallback){
  const out = normalizeStr(name)
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g,'')
    .replace(/[^a-zA-Z0-9_\-]+/g,'_')
    .replace(/_+/g,'_')
    .replace(/^_+|_+$/g,'');
  return out || fallback || 'Archivo';
}

async function getExportFrame(){
  if(__exportFrame && __exportFrame.contentWindow && __exportFrame.contentDocument) return __exportFrame;

  const frame = document.createElement('iframe');
  frame.style.position = 'fixed';
  frame.style.left = '-10000px';
  frame.style.top = '0';
  frame.style.width = '1024px';
  frame.style.height = '768px';
  frame.style.opacity = '0';
  frame.style.pointerEvents = 'none';
  frame.setAttribute('aria-hidden', 'true');
  document.body.appendChild(frame);

  const doc = frame.contentDocument;
  doc.open();
  doc.write(`<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Export PDF</title>
<style>
  :root{
    --page-bg:#ffffff;
    --border:#000000;
    --shadow: rgba(0,0,0,.12);

    --header-bg:#ffffff;
    --header-text:#000000;

    --section-bg:#e6e6e6;
    --section-text:#000000;

    --body-bg:#ffffff;
    --body-text:#000000;

    --w95-bg:#c0c0c0;
    --w95-light:#ffffff;
    --w95-shadow:#404040;
    --w95-blue:#000080;
    --w95-hilite:#dfdfdf;
  }

  *{ box-sizing:border-box; }
  body{
    margin:0;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    background:#f5f5f5;
    color:var(--body-text);
  }

  .page{
    width: 900px;
    max-width: 100%;
    margin: 22px auto;
    background: var(--page-bg);
    border: 1px solid var(--border);
    box-shadow: 0 10px 30px var(--shadow);
    padding: 18px 18px 22px;
  }

  .doc-header{
    display:grid;
    grid-template-columns: 120px 1fr 190px;
    gap: 14px;
    align-items:center;
    padding: 12px;
    border: 1px solid var(--border);
    background: var(--header-bg);
    color: var(--header-text);
  }
  .logo{
    width: 120px;
    height: 70px;
    border: 1px solid var(--border);
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
  }
  .header-title{
    font-weight: 900;
    font-size: 18px;
    line-height: 1.15;
  }
  .header-subtitle{
    margin-top: 4px;
    font-size: 13px;
    opacity:.9;
  }
  .header-meta{
    text-align:right;
    font-size: 12px;
    line-height: 1.35;
  }
  .muted{ opacity:.75; }

  #fieldsMount{ margin-top: 10px; }

  .field{
    border: 1px solid var(--border);
    margin-top: 10px;
    background: var(--body-bg);
  }
  .field-head{
    padding: 8px 10px;
    background: var(--section-bg);
    color: var(--section-text);
    border-bottom: 1px solid var(--border);
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap: 10px;
  }
  .field-head .title{
    font-weight: 900;
    font-size: 13px;
  }
  .field-body{
    padding: 10px;
    font-size: 13px;
  }

  input[type="text"], input[type="number"], input[type="date"], textarea, select{
    width:100%;
    border: 1px solid var(--border);
    font: inherit;
    background:#fff;

    /* ✅ FIX: evita que html2canvas recorte el texto por abajo (descenders) */
    line-height: 1.35;
    padding: 9px 10px 11px;
  }
  input[type="text"], input[type="number"], input[type="date"], select{
    height: 34px;
  }
  textarea{
    min-height: 90px;
    resize: vertical;
    padding-bottom: 14px;
  }

  .checkline{
    display:flex;
    align-items:center;
    gap:10px;
  }

  .photoGrid{
    display:grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
  }
  .photoItem{
    border: 1px solid var(--border);
    padding: 6px;
    background:#fff;
  }
  .photoItem img{
    width:100%;
    height:160px;
    object-fit:cover;
    display:block;
    border: 1px solid #ddd;
  }

  body.exporting .uiOnly{ display:none !important; }
</style>
</head>
<body>
<div id="capture" class="page">
  <div id="docHeader" class="doc-header">
    <div class="logo" id="logoBox"></div>
    <div class="header-text">
      <div id="docTitle" class="header-title"></div>
      <div id="docSubtitle" class="header-subtitle"></div>
    </div>
    <div class="header-meta">
      <div class="muted">Última edición</div>
      <div id="lastEdited">—</div>
    </div>
  </div>
  <div id="fieldsMount"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"><\/script>
<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"><\/script>
<script>
  function escapeHTML(str){
    return String(str ?? '')
      .replaceAll('&','&amp;')
      .replaceAll('<','&lt;')
      .replaceAll('>','&gt;')
      .replaceAll('"','&quot;')
      .replaceAll("'","&#039;");
  }

  function normalize(s){ return String(s ?? '').trim().toLowerCase(); }

  function fieldHTML(d, idx){
    const type = normalize(d.type) || 'text';
    const title = (d.title ?? '').toString();
    const config = (d.config && typeof d.config==='object') ? d.config : {};

    if(type === 'text'){
      const v = (d.value ?? '').toString();
      return \`
        <div class="field" data-type="text" data-idx="\${idx}">
          <div class="field-head">
            <div class="title">\${escapeHTML(title)}</div>
          </div>
          <div class="field-body textline">
            <input type="text" value="\${escapeHTML(v)}" />
          </div>
        </div>
      \`;
    }

    if(type === 'textarea'){
      const v = (d.value ?? '').toString();
      return \`
        <div class="field" data-type="textarea" data-idx="\${idx}">
          <div class="field-head">
            <div class="title">\${escapeHTML(title)}</div>
          </div>
          <div class="field-body">
            <textarea>\${escapeHTML(v)}</textarea>
          </div>
        </div>
      \`;
    }

    if(type === 'number'){
      const v = (d.value ?? '').toString();
      return \`
        <div class="field" data-type="number" data-idx="\${idx}">
          <div class="field-head">
            <div class="title">\${escapeHTML(title)}</div>
          </div>
          <div class="field-body">
            <input type="number" value="\${escapeHTML(v)}" />
          </div>
        </div>
      \`;
    }

    if(type === 'date'){
      const v = (d.value ?? '').toString();
      return \`
        <div class="field" data-type="date" data-idx="\${idx}">
          <div class="field-head">
            <div class="title">\${escapeHTML(title)}</div>
          </div>
          <div class="field-body">
            <input type="date" value="\${escapeHTML(v)}" />
          </div>
        </div>
      \`;
    }

    if(type === 'select'){
      const v = (d.value ?? '').toString();
      const options = Array.isArray(config.options) ? config.options : [];
      const optsHTML = options.map(o=>{
        const val = (o ?? '').toString();
        const sel = val === v ? 'selected' : '';
        return \`<option \${sel} value="\${escapeHTML(val)}">\${escapeHTML(val)}</option>\`;
      }).join('');
      return \`
        <div class="field" data-type="select" data-idx="\${idx}">
          <div class="field-head">
            <div class="title">\${escapeHTML(title)}</div>
          </div>
          <div class="field-body">
            <select>\${optsHTML}</select>
          </div>
        </div>
      \`;
    }

    if(type === 'check'){
      const v = !!d.value;
      const label = (config.label ?? 'Sí/No').toString();
      const checked = v ? 'checked' : '';
      return \`
        <div class="field" data-type="check" data-idx="\${idx}">
          <div class="field-head">
            <div class="title">\${escapeHTML(title)}</div>
          </div>
          <div class="field-body">
            <label class="checkline">
              <input type="checkbox" \${checked} />
              <span>\${escapeHTML(label)}</span>
            </label>
          </div>
        </div>
      \`;
    }

    if(type === 'photos'){
      const images = Array.isArray(d.images) ? d.images : [];
      const grid = images.map((src, i)=>{
        const safe = (src ?? '').toString();
        return \`
          <div class="photoItem">
            <img src="\${escapeHTML(safe)}" alt="Foto \${i+1}" />
          </div>
        \`;
      }).join('');
      return \`
        <div class="field" data-type="photos" data-idx="\${idx}">
          <div class="field-head">
            <div class="title">\${escapeHTML(title)}</div>
          </div>
          <div class="field-body">
            <div class="photoGrid">\${grid || '<div class="muted">—</div>'}</div>
          </div>
        </div>
      \`;
    }

    const v = (d.value ?? '').toString();
    return \`
      <div class="field" data-type="unknown" data-idx="\${idx}">
        <div class="field-head">
          <div class="title">\${escapeHTML(title || type)}</div>
        </div>
        <div class="field-body">\${escapeHTML(v)}</div>
      </div>
    \`;
  }

  function applyTheme(theme){
    if(!theme || typeof theme !== 'object') return;
    const root = document.documentElement;
    const map = {
      border: '--border',
      bodyBg: '--body-bg',
      bodyText: '--body-text',
      headerBg: '--header-bg',
      headerText: '--header-text',
      sectionBg: '--section-bg',
      sectionText: '--section-text',
      pageBg: '--page-bg'
    };
    for(const k in map){
      if(theme[k]) root.style.setProperty(map[k], String(theme[k]));
    }
  }

  function renderLayout(layout){
    if(!layout || typeof layout !== 'object') return;
    const header = (layout.header && typeof layout.header==='object') ? layout.header : {};
    const meta = (layout.meta && typeof layout.meta==='object') ? layout.meta : {};

    applyTheme(layout.theme);

    const title = (header.title ?? meta.name ?? meta.form ?? '').toString() || '—';
    const subtitle = (header.subtitle ?? meta.subtitle ?? meta.category ?? '').toString() || '';
    const lastEdited = (header.lastEdited ?? '').toString() || '—';
    const logo = (header.logo ?? '').toString();

    document.getElementById('docTitle').textContent = title;
    document.getElementById('docSubtitle').textContent = subtitle;
    document.getElementById('lastEdited').textContent = lastEdited;

    const logoBox = document.getElementById('logoBox');
    if(logo){
      logoBox.style.backgroundImage = \`url("\${logo}")\`;
    }else{
      logoBox.style.backgroundImage = 'none';
    }

    const mount = document.getElementById('fieldsMount');
    const fields = Array.isArray(layout.fields) ? layout.fields : [];
    mount.innerHTML = fields.map((d,i)=>fieldHTML(d,i)).join('');
  }

  async function saveSingleFile(blob, filename){
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename || 'informe.pdf';
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{
      URL.revokeObjectURL(url);
      a.remove();
    }, 2500);
  }

  async function exportPDFLikeInspector(filename){
    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF({ orientation:'p', unit:'mm', format:'a4' });

    const pageW = 210;
    const pageH = 297;
    const margin = 10;
    const contentW = pageW - margin*2;
    const contentH = pageH - margin*2;

    document.body.classList.add('exporting');

    async function renderEl(element){
      return await html2canvas(element, {
        scale: 2,
        backgroundColor: '#ffffff',
        useCORS: true,
        scrollX: 0,
        scrollY: -window.scrollY,
        onclone: (doc)=>{
          const cap = doc.getElementById('capture');
          if(cap){ cap.style.boxShadow = 'none'; cap.style.margin = '0'; }
          doc.querySelectorAll('.uiOnly').forEach(a => a.style.display = 'none');
        }
      });
    }

    try{
      const header = document.getElementById('docHeader');
      const fields = [...document.querySelectorAll('#capture .field')];
      const blocks = [header, ...fields];

      let cursorY = margin;

      for(const block of blocks){
        const canvas = await renderEl(block);
        const imgData = canvas.toDataURL('image/jpeg', 0.95);

        let blockWmm = contentW;
        let blockHmm = (canvas.height * blockWmm) / canvas.width;

        if(blockHmm > contentH){
          const scaleFactor = contentH / blockHmm;
          blockWmm = blockWmm * scaleFactor;
          blockHmm = contentH;
        }

        if(cursorY + blockHmm > (pageH - margin)){
          pdf.addPage();
          cursorY = margin;
        }

        const x = margin + (contentW - blockWmm) / 2;
        pdf.addImage(imgData, 'JPEG', x, cursorY, blockWmm, blockHmm);
        cursorY += blockHmm + 2;
      }

      const pdfBlob = pdf.output('blob');
      await saveSingleFile(pdfBlob, filename);
    } finally {
      document.body.classList.remove('exporting');
    }
  }

  window.renderAndExport = async function(layout, filename){
    renderLayout(layout);
    await new Promise(r=>setTimeout(r, 30));
    await exportPDFLikeInspector(filename);
  };
<\/script>
</body>
</html>`);
  doc.close();

  await new Promise((resolve, reject)=>{
    const start = Date.now();
    (function tick(){
      try{
        const w = frame.contentWindow;
        if(w && w.jspdf && w.html2canvas && typeof w.renderAndExport === 'function') return resolve();
      }catch(e){}
      if(Date.now() - start > 10000) return reject(new Error('No se pudieron cargar librerías de exportación.'));
      setTimeout(tick, 50);
    })();
  });

  __exportFrame = frame;
  return frame;
}

async function exportRecordPDF(id){
  // Usa cache; si no existe, intenta buscar en Firestore directo
  let rec = getCache().find(x => x && x.id === id);

  if(!rec){
    try{
      assertFirestoreReady();
      const doc = await __fire.col.doc(String(id)).get();
      if(doc.exists){
        rec = templateToRecord({ id: doc.id, ...(doc.data() || {}) });
      }
    }catch(e){}
  }

  if(!rec){
    alert('No se encontró el registro.');
    return;
  }

  const raw = rec.raw || rec;
  const layout = extractLayout(raw);
  if(!layout){
    alert('El registro no contiene un layout válido para exportar.');
    return;
  }

  layout.meta = (layout.meta && typeof layout.meta==='object') ? layout.meta : {};
  layout.meta.category = layout.meta.category || rec.category || '';
  layout.meta.name = layout.meta.name || rec.form || '';

  layout.header = (layout.header && typeof layout.header==='object') ? layout.header : {};
  if(!layout.header.lastEdited) layout.header.lastEdited = rec.lastEditedISO || nowISO();

  const safeCat = makeSafeName(rec.category || layout.meta.category || 'Categoria', 'Categoria');
  const safeForm = makeSafeName(rec.form || layout.meta.name || 'Formulario', 'Formulario');
  const filename = `informe_${safeCat}__${safeForm}__${exportStamp(new Date())}.pdf`;

  try{
    const frame = await getExportFrame();
    await frame.contentWindow.renderAndExport(layout, filename);
  }catch(e){
    console.error(e);
    alert('No se pudo exportar el PDF.');
  }
}

function goHome(){
  window.location.href = "index.html";
}

/* =========================
   5) Buscar por TAG/código (Firestore)
   =========================
   Este helper NO cambia la UI existente; si quieres usarlo desde consola:
   await window.findAndFocusByCode('abcd1234');
*/
window.findAndFocusByCode = async function(code){
  try{
    const tpl = await findByCode(code);
    if(!tpl){
      alert('No se encontró ninguna inspección con ese TAG/código.');
      return null;
    }
    const rec = templateToRecord(tpl);

    // Carga/actualiza cache y centra el filtro rápido en el código
    await refreshCache();
    document.getElementById('histSearch').value = String(code);
    __page = 1;
    await renderList();
    return rec;
  }catch(e){
    console.error(e);
    alert('No se pudo buscar por TAG/código.');
    return null;
  }
};

/* =========================
   Firebase init + arranque
   ========================= */
async function initFirestore(){
  try{
    if(!firebase.apps || !firebase.apps.length){
      __fire.app = firebase.initializeApp(firebaseConfig);
    }else{
      __fire.app = firebase.app();
    }
    __fire.db = firebase.firestore();
    __fire.col = __fire.db.collection(COLLECTION_NAME);
  }catch(e){
    console.error(e);
    throw e;
  }
}

async function initApp(){
  await initFirestore();
  await renderList();

  // Enter en búsqueda rápida => buscar
  const hs = document.getElementById('histSearch');
  if(hs){
    hs.addEventListener('keydown', (ev)=>{
      if(ev.key==='Enter'){ ev.preventDefault(); runSearch(); }
    });
  }
}

// Init
initApp();


function exportJSON(){
  alert('Modo nube: la base de datos lee directamente desde Firestore.\n\nSi necesitas una copia, usa la exportación PDF o añade una función de backup server-side.');
}
function importJsonFiles(){
  alert('Modo nube: no se importan JSON locales.\n\nLa fuente de verdad es Firestore.');
}

function clearAll(){
  // compat: algunos botones/atajos llaman clearAll
  return clearDB();
}

// --- Bindings explícitos para botones inline (robustez) ---
try{
  window.refreshCache = refreshCache;
  window.runSearch = runSearch;
  window.loadAllFromCloud = loadAllFromCloud;
  window.clearDB = clearDB;
  window.clearAll = clearAll;
  window.exportJSON = exportJSON;
  window.importJsonFiles = importJsonFiles;
}catch(e){ console.error(e); }

</script>
</body>
</html>
